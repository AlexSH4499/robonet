# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Leap')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Leap')
    _Leap = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Leap', [dirname(__file__)])
        except ImportError:
            import _Leap
            return _Leap
        try:
            _mod = imp.load_module('_Leap', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Leap = swig_import_helper()
    del swig_import_helper
else:
    import _Leap
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Leap.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _Leap.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Leap.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Leap.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Leap.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Leap.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Leap.SwigPyIterator_copy(self)

    def next(self):
        return _Leap.SwigPyIterator_next(self)

    def __next__(self):
        return _Leap.SwigPyIterator___next__(self)

    def previous(self):
        return _Leap.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Leap.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Leap.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Leap.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Leap.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Leap.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Leap.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Leap.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Leap.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class byte_array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, byte_array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, byte_array, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _Leap.new_byte_array(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Leap.delete_byte_array
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _Leap.byte_array___getitem__(self, index)

    def __setitem__(self, index, value):
        return _Leap.byte_array___setitem__(self, index, value)

    def cast(self):
        return _Leap.byte_array_cast(self)
    if _newclass:
        frompointer = staticmethod(_Leap.byte_array_frompointer)
    else:
        frompointer = _Leap.byte_array_frompointer
byte_array_swigregister = _Leap.byte_array_swigregister
byte_array_swigregister(byte_array)

def byte_array_frompointer(t):
    return _Leap.byte_array_frompointer(t)
byte_array_frompointer = _Leap.byte_array_frompointer

class float_array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, float_array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, float_array, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        this = _Leap.new_float_array(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Leap.delete_float_array
    __del__ = lambda self: None

    def __getitem__(self, index):
        return _Leap.float_array___getitem__(self, index)

    def __setitem__(self, index, value):
        return _Leap.float_array___setitem__(self, index, value)

    def cast(self):
        return _Leap.float_array_cast(self)
    if _newclass:
        frompointer = staticmethod(_Leap.float_array_frompointer)
    else:
        frompointer = _Leap.float_array_frompointer
float_array_swigregister = _Leap.float_array_swigregister
float_array_swigregister(float_array)

def float_array_frompointer(t):
    return _Leap.float_array_frompointer(t)
float_array_frompointer = _Leap.float_array_frompointer

class Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Leap.new_Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def distance_to(self, other):
        return _Leap.Vector_distance_to(self, other)

    def angle_to(self, other):
        return _Leap.Vector_angle_to(self, other)

    def dot(self, other):
        return _Leap.Vector_dot(self, other)

    def cross(self, other):
        return _Leap.Vector_cross(self, other)

    def __neg__(self):
        return _Leap.Vector___neg__(self)

    def __add__(self, other):
        return _Leap.Vector___add__(self, other)

    def __sub__(self, other):
        return _Leap.Vector___sub__(self, other)

    def __mul__(self, scalar):
        return _Leap.Vector___mul__(self, scalar)

    def __truediv__(self, *args):
        return _Leap.Vector___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, other):
        return _Leap.Vector___iadd__(self, other)

    def __isub__(self, other):
        return _Leap.Vector___isub__(self, other)

    def __imul__(self, scalar):
        return _Leap.Vector___imul__(self, scalar)

    def __itruediv__(self, *args):
        return _Leap.Vector___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __str__(self):
        return _Leap.Vector___str__(self)

    def __eq__(self, other):
        return _Leap.Vector___eq__(self, other)

    def __ne__(self, other):
        return _Leap.Vector___ne__(self, other)

    def is_valid(self):
        return _Leap.Vector_is_valid(self)

    def __getitem__(self, index):
        return _Leap.Vector___getitem__(self, index)
    __swig_setmethods__["x"] = _Leap.Vector_x_set
    __swig_getmethods__["x"] = _Leap.Vector_x_get
    if _newclass:
        x = _swig_property(_Leap.Vector_x_get, _Leap.Vector_x_set)
    __swig_setmethods__["y"] = _Leap.Vector_y_set
    __swig_getmethods__["y"] = _Leap.Vector_y_get
    if _newclass:
        y = _swig_property(_Leap.Vector_y_get, _Leap.Vector_y_set)
    __swig_setmethods__["z"] = _Leap.Vector_z_set
    __swig_getmethods__["z"] = _Leap.Vector_z_get
    if _newclass:
        z = _swig_property(_Leap.Vector_z_get, _Leap.Vector_z_set)
    __swig_getmethods__["magnitude"] = _Leap.Vector_magnitude_get
    if _newclass:
        magnitude = _swig_property(_Leap.Vector_magnitude_get)
    __swig_getmethods__["magnitude_squared"] = _Leap.Vector_magnitude_squared_get
    if _newclass:
        magnitude_squared = _swig_property(_Leap.Vector_magnitude_squared_get)
    __swig_getmethods__["pitch"] = _Leap.Vector_pitch_get
    if _newclass:
        pitch = _swig_property(_Leap.Vector_pitch_get)
    __swig_getmethods__["roll"] = _Leap.Vector_roll_get
    if _newclass:
        roll = _swig_property(_Leap.Vector_roll_get)
    __swig_getmethods__["yaw"] = _Leap.Vector_yaw_get
    if _newclass:
        yaw = _swig_property(_Leap.Vector_yaw_get)
    __swig_getmethods__["normalized"] = _Leap.Vector_normalized_get
    if _newclass:
        normalized = _swig_property(_Leap.Vector_normalized_get)

    def to_float_array(self): return [self.x, self.y, self.z]
    def to_tuple(self): return (self.x, self.y, self.z)

    __swig_destroy__ = _Leap.delete_Vector
    __del__ = lambda self: None
Vector_swigregister = _Leap.Vector_swigregister
Vector_swigregister(Vector)
cvar = _Leap.cvar
PI = cvar.PI
DEG_TO_RAD = cvar.DEG_TO_RAD
RAD_TO_DEG = cvar.RAD_TO_DEG
EPSILON = cvar.EPSILON
Vector.zero = _Leap.cvar.Vector_zero
Vector.x_axis = _Leap.cvar.Vector_x_axis
Vector.y_axis = _Leap.cvar.Vector_y_axis
Vector.z_axis = _Leap.cvar.Vector_z_axis
Vector.forward = _Leap.cvar.Vector_forward
Vector.backward = _Leap.cvar.Vector_backward
Vector.left = _Leap.cvar.Vector_left
Vector.right = _Leap.cvar.Vector_right
Vector.up = _Leap.cvar.Vector_up
Vector.down = _Leap.cvar.Vector_down

class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Leap.new_Matrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_rotation(self, axis, angleRadians):
        return _Leap.Matrix_set_rotation(self, axis, angleRadians)

    def transform_point(self, arg2):
        return _Leap.Matrix_transform_point(self, arg2)

    def transform_direction(self, arg2):
        return _Leap.Matrix_transform_direction(self, arg2)

    def rigid_inverse(self):
        return _Leap.Matrix_rigid_inverse(self)

    def __mul__(self, other):
        return _Leap.Matrix___mul__(self, other)

    def __imul__(self, other):
        return _Leap.Matrix___imul__(self, other)

    def __eq__(self, other):
        return _Leap.Matrix___eq__(self, other)

    def __ne__(self, other):
        return _Leap.Matrix___ne__(self, other)

    def __str__(self):
        return _Leap.Matrix___str__(self)
    __swig_setmethods__["x_basis"] = _Leap.Matrix_x_basis_set
    __swig_getmethods__["x_basis"] = _Leap.Matrix_x_basis_get
    if _newclass:
        x_basis = _swig_property(_Leap.Matrix_x_basis_get, _Leap.Matrix_x_basis_set)
    __swig_setmethods__["y_basis"] = _Leap.Matrix_y_basis_set
    __swig_getmethods__["y_basis"] = _Leap.Matrix_y_basis_get
    if _newclass:
        y_basis = _swig_property(_Leap.Matrix_y_basis_get, _Leap.Matrix_y_basis_set)
    __swig_setmethods__["z_basis"] = _Leap.Matrix_z_basis_set
    __swig_getmethods__["z_basis"] = _Leap.Matrix_z_basis_get
    if _newclass:
        z_basis = _swig_property(_Leap.Matrix_z_basis_get, _Leap.Matrix_z_basis_set)
    __swig_setmethods__["origin"] = _Leap.Matrix_origin_set
    __swig_getmethods__["origin"] = _Leap.Matrix_origin_get
    if _newclass:
        origin = _swig_property(_Leap.Matrix_origin_get, _Leap.Matrix_origin_set)

    def to_array_3x3(self, output = None):
        if output is None:
            output = [0]*9
        output[0], output[1], output[2] = self.x_basis.x, self.x_basis.y, self.x_basis.z
        output[3], output[4], output[5] = self.y_basis.x, self.y_basis.y, self.y_basis.z
        output[6], output[7], output[8] = self.z_basis.x, self.z_basis.y, self.z_basis.z
        return output
    def to_array_4x4(self, output = None):
        if output is None:
            output = [0]*16
        output[0],  output[1],  output[2],  output[3]  = self.x_basis.x, self.x_basis.y, self.x_basis.z, 0.0
        output[4],  output[5],  output[6],  output[7]  = self.y_basis.x, self.y_basis.y, self.y_basis.z, 0.0
        output[8],  output[9],  output[10], output[11] = self.z_basis.x, self.z_basis.y, self.z_basis.z, 0.0
        output[12], output[13], output[14], output[15] = self.origin.x,  self.origin.y,  self.origin.z,  1.0
        return output

    __swig_destroy__ = _Leap.delete_Matrix
    __del__ = lambda self: None
Matrix_swigregister = _Leap.Matrix_swigregister
Matrix_swigregister(Matrix)
Matrix.identity = _Leap.cvar.Matrix_identity

class Interface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
Interface_swigregister = _Leap.Interface_swigregister
Interface_swigregister(Interface)

class Pointable(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pointable, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pointable, name)
    __repr__ = _swig_repr
    ZONE_NONE = _Leap.Pointable_ZONE_NONE
    ZONE_HOVERING = _Leap.Pointable_ZONE_HOVERING
    ZONE_TOUCHING = _Leap.Pointable_ZONE_TOUCHING

    def __init__(self):
        this = _Leap.new_Pointable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, arg2):
        return _Leap.Pointable___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Pointable___ne__(self, arg2)

    def __str__(self):
        return _Leap.Pointable___str__(self)
    __swig_getmethods__["id"] = _Leap.Pointable_id_get
    if _newclass:
        id = _swig_property(_Leap.Pointable_id_get)
    __swig_getmethods__["hand"] = _Leap.Pointable_hand_get
    if _newclass:
        hand = _swig_property(_Leap.Pointable_hand_get)
    __swig_getmethods__["tip_position"] = _Leap.Pointable_tip_position_get
    if _newclass:
        tip_position = _swig_property(_Leap.Pointable_tip_position_get)
    __swig_getmethods__["tip_velocity"] = _Leap.Pointable_tip_velocity_get
    if _newclass:
        tip_velocity = _swig_property(_Leap.Pointable_tip_velocity_get)
    __swig_getmethods__["direction"] = _Leap.Pointable_direction_get
    if _newclass:
        direction = _swig_property(_Leap.Pointable_direction_get)
    __swig_getmethods__["width"] = _Leap.Pointable_width_get
    if _newclass:
        width = _swig_property(_Leap.Pointable_width_get)
    __swig_getmethods__["length"] = _Leap.Pointable_length_get
    if _newclass:
        length = _swig_property(_Leap.Pointable_length_get)
    __swig_getmethods__["is_tool"] = _Leap.Pointable_is_tool_get
    if _newclass:
        is_tool = _swig_property(_Leap.Pointable_is_tool_get)
    __swig_getmethods__["is_finger"] = _Leap.Pointable_is_finger_get
    if _newclass:
        is_finger = _swig_property(_Leap.Pointable_is_finger_get)
    __swig_getmethods__["is_extended"] = _Leap.Pointable_is_extended_get
    if _newclass:
        is_extended = _swig_property(_Leap.Pointable_is_extended_get)
    __swig_getmethods__["is_valid"] = _Leap.Pointable_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Pointable_is_valid_get)
    __swig_getmethods__["touch_zone"] = _Leap.Pointable_touch_zone_get
    if _newclass:
        touch_zone = _swig_property(_Leap.Pointable_touch_zone_get)
    __swig_getmethods__["touch_distance"] = _Leap.Pointable_touch_distance_get
    if _newclass:
        touch_distance = _swig_property(_Leap.Pointable_touch_distance_get)
    __swig_getmethods__["stabilized_tip_position"] = _Leap.Pointable_stabilized_tip_position_get
    if _newclass:
        stabilized_tip_position = _swig_property(_Leap.Pointable_stabilized_tip_position_get)
    __swig_getmethods__["time_visible"] = _Leap.Pointable_time_visible_get
    if _newclass:
        time_visible = _swig_property(_Leap.Pointable_time_visible_get)
    __swig_getmethods__["frame"] = _Leap.Pointable_frame_get
    if _newclass:
        frame = _swig_property(_Leap.Pointable_frame_get)
    __swig_destroy__ = _Leap.delete_Pointable
    __del__ = lambda self: None
Pointable_swigregister = _Leap.Pointable_swigregister
Pointable_swigregister(Pointable)
Pointable.invalid = _Leap.cvar.Pointable_invalid

class Arm(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Arm, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Arm, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_Arm()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, arg2):
        return _Leap.Arm___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Arm___ne__(self, arg2)

    def __str__(self):
        return _Leap.Arm___str__(self)
    __swig_getmethods__["width"] = _Leap.Arm_width_get
    if _newclass:
        width = _swig_property(_Leap.Arm_width_get)
    __swig_getmethods__["center"] = _Leap.Arm_center_get
    if _newclass:
        center = _swig_property(_Leap.Arm_center_get)
    __swig_getmethods__["direction"] = _Leap.Arm_direction_get
    if _newclass:
        direction = _swig_property(_Leap.Arm_direction_get)
    __swig_getmethods__["basis"] = _Leap.Arm_basis_get
    if _newclass:
        basis = _swig_property(_Leap.Arm_basis_get)
    __swig_getmethods__["elbow_position"] = _Leap.Arm_elbow_position_get
    if _newclass:
        elbow_position = _swig_property(_Leap.Arm_elbow_position_get)
    __swig_getmethods__["wrist_position"] = _Leap.Arm_wrist_position_get
    if _newclass:
        wrist_position = _swig_property(_Leap.Arm_wrist_position_get)
    __swig_getmethods__["is_valid"] = _Leap.Arm_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Arm_is_valid_get)
    __swig_destroy__ = _Leap.delete_Arm
    __del__ = lambda self: None
Arm_swigregister = _Leap.Arm_swigregister
Arm_swigregister(Arm)
Arm.invalid = _Leap.cvar.Arm_invalid

class Bone(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bone, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Bone, name)
    __repr__ = _swig_repr
    TYPE_METACARPAL = _Leap.Bone_TYPE_METACARPAL
    TYPE_PROXIMAL = _Leap.Bone_TYPE_PROXIMAL
    TYPE_INTERMEDIATE = _Leap.Bone_TYPE_INTERMEDIATE
    TYPE_DISTAL = _Leap.Bone_TYPE_DISTAL

    def __init__(self):
        this = _Leap.new_Bone()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, arg2):
        return _Leap.Bone___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Bone___ne__(self, arg2)

    def __str__(self):
        return _Leap.Bone___str__(self)
    __swig_getmethods__["prev_joint"] = _Leap.Bone_prev_joint_get
    if _newclass:
        prev_joint = _swig_property(_Leap.Bone_prev_joint_get)
    __swig_getmethods__["next_joint"] = _Leap.Bone_next_joint_get
    if _newclass:
        next_joint = _swig_property(_Leap.Bone_next_joint_get)
    __swig_getmethods__["center"] = _Leap.Bone_center_get
    if _newclass:
        center = _swig_property(_Leap.Bone_center_get)
    __swig_getmethods__["direction"] = _Leap.Bone_direction_get
    if _newclass:
        direction = _swig_property(_Leap.Bone_direction_get)
    __swig_getmethods__["length"] = _Leap.Bone_length_get
    if _newclass:
        length = _swig_property(_Leap.Bone_length_get)
    __swig_getmethods__["width"] = _Leap.Bone_width_get
    if _newclass:
        width = _swig_property(_Leap.Bone_width_get)
    __swig_getmethods__["type"] = _Leap.Bone_type_get
    if _newclass:
        type = _swig_property(_Leap.Bone_type_get)
    __swig_getmethods__["basis"] = _Leap.Bone_basis_get
    if _newclass:
        basis = _swig_property(_Leap.Bone_basis_get)
    __swig_getmethods__["is_valid"] = _Leap.Bone_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Bone_is_valid_get)
    __swig_destroy__ = _Leap.delete_Bone
    __del__ = lambda self: None
Bone_swigregister = _Leap.Bone_swigregister
Bone_swigregister(Bone)
Bone.invalid = _Leap.cvar.Bone_invalid

class Finger(Pointable):
    __swig_setmethods__ = {}
    for _s in [Pointable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Finger, name, value)
    __swig_getmethods__ = {}
    for _s in [Pointable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Finger, name)
    __repr__ = _swig_repr
    JOINT_MCP = _Leap.Finger_JOINT_MCP
    JOINT_PIP = _Leap.Finger_JOINT_PIP
    JOINT_DIP = _Leap.Finger_JOINT_DIP
    JOINT_TIP = _Leap.Finger_JOINT_TIP
    TYPE_THUMB = _Leap.Finger_TYPE_THUMB
    TYPE_INDEX = _Leap.Finger_TYPE_INDEX
    TYPE_MIDDLE = _Leap.Finger_TYPE_MIDDLE
    TYPE_RING = _Leap.Finger_TYPE_RING
    TYPE_PINKY = _Leap.Finger_TYPE_PINKY

    def __init__(self, *args):
        this = _Leap.new_Finger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def joint_position(self, jointIx):
        return _Leap.Finger_joint_position(self, jointIx)

    def bone(self, boneIx):
        return _Leap.Finger_bone(self, boneIx)

    def __str__(self):
        return _Leap.Finger___str__(self)
    __swig_getmethods__["type"] = _Leap.Finger_type_get
    if _newclass:
        type = _swig_property(_Leap.Finger_type_get)
    __swig_destroy__ = _Leap.delete_Finger
    __del__ = lambda self: None
Finger_swigregister = _Leap.Finger_swigregister
Finger_swigregister(Finger)
Finger.invalid = _Leap.cvar.Finger_invalid

class Tool(Pointable):
    __swig_setmethods__ = {}
    for _s in [Pointable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tool, name, value)
    __swig_getmethods__ = {}
    for _s in [Pointable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Leap.new_Tool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _Leap.Tool___str__(self)
    __swig_destroy__ = _Leap.delete_Tool
    __del__ = lambda self: None
Tool_swigregister = _Leap.Tool_swigregister
Tool_swigregister(Tool)
Tool.invalid = _Leap.cvar.Tool_invalid

class Hand(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hand, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hand, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_Hand()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def pointable(self, id):
        return _Leap.Hand_pointable(self, id)

    def finger(self, id):
        return _Leap.Hand_finger(self, id)

    def translation(self, sinceFrame):
        return _Leap.Hand_translation(self, sinceFrame)

    def translation_probability(self, sinceFrame):
        return _Leap.Hand_translation_probability(self, sinceFrame)

    def rotation_axis(self, sinceFrame):
        return _Leap.Hand_rotation_axis(self, sinceFrame)

    def rotation_angle(self, *args):
        return _Leap.Hand_rotation_angle(self, *args)

    def rotation_matrix(self, sinceFrame):
        return _Leap.Hand_rotation_matrix(self, sinceFrame)

    def rotation_probability(self, sinceFrame):
        return _Leap.Hand_rotation_probability(self, sinceFrame)

    def scale_factor(self, sinceFrame):
        return _Leap.Hand_scale_factor(self, sinceFrame)

    def scale_probability(self, sinceFrame):
        return _Leap.Hand_scale_probability(self, sinceFrame)

    def __eq__(self, arg2):
        return _Leap.Hand___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Hand___ne__(self, arg2)

    def __str__(self):
        return _Leap.Hand___str__(self)
    __swig_getmethods__["id"] = _Leap.Hand_id_get
    if _newclass:
        id = _swig_property(_Leap.Hand_id_get)
    __swig_getmethods__["pointables"] = _Leap.Hand_pointables_get
    if _newclass:
        pointables = _swig_property(_Leap.Hand_pointables_get)
    __swig_getmethods__["fingers"] = _Leap.Hand_fingers_get
    if _newclass:
        fingers = _swig_property(_Leap.Hand_fingers_get)
    __swig_getmethods__["palm_position"] = _Leap.Hand_palm_position_get
    if _newclass:
        palm_position = _swig_property(_Leap.Hand_palm_position_get)
    __swig_getmethods__["palm_velocity"] = _Leap.Hand_palm_velocity_get
    if _newclass:
        palm_velocity = _swig_property(_Leap.Hand_palm_velocity_get)
    __swig_getmethods__["palm_normal"] = _Leap.Hand_palm_normal_get
    if _newclass:
        palm_normal = _swig_property(_Leap.Hand_palm_normal_get)
    __swig_getmethods__["direction"] = _Leap.Hand_direction_get
    if _newclass:
        direction = _swig_property(_Leap.Hand_direction_get)
    __swig_getmethods__["basis"] = _Leap.Hand_basis_get
    if _newclass:
        basis = _swig_property(_Leap.Hand_basis_get)
    __swig_getmethods__["is_valid"] = _Leap.Hand_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Hand_is_valid_get)
    __swig_getmethods__["sphere_center"] = _Leap.Hand_sphere_center_get
    if _newclass:
        sphere_center = _swig_property(_Leap.Hand_sphere_center_get)
    __swig_getmethods__["sphere_radius"] = _Leap.Hand_sphere_radius_get
    if _newclass:
        sphere_radius = _swig_property(_Leap.Hand_sphere_radius_get)
    __swig_getmethods__["grab_angle"] = _Leap.Hand_grab_angle_get
    if _newclass:
        grab_angle = _swig_property(_Leap.Hand_grab_angle_get)
    __swig_getmethods__["pinch_distance"] = _Leap.Hand_pinch_distance_get
    if _newclass:
        pinch_distance = _swig_property(_Leap.Hand_pinch_distance_get)
    __swig_getmethods__["grab_strength"] = _Leap.Hand_grab_strength_get
    if _newclass:
        grab_strength = _swig_property(_Leap.Hand_grab_strength_get)
    __swig_getmethods__["pinch_strength"] = _Leap.Hand_pinch_strength_get
    if _newclass:
        pinch_strength = _swig_property(_Leap.Hand_pinch_strength_get)
    __swig_getmethods__["palm_width"] = _Leap.Hand_palm_width_get
    if _newclass:
        palm_width = _swig_property(_Leap.Hand_palm_width_get)
    __swig_getmethods__["stabilized_palm_position"] = _Leap.Hand_stabilized_palm_position_get
    if _newclass:
        stabilized_palm_position = _swig_property(_Leap.Hand_stabilized_palm_position_get)
    __swig_getmethods__["wrist_position"] = _Leap.Hand_wrist_position_get
    if _newclass:
        wrist_position = _swig_property(_Leap.Hand_wrist_position_get)
    __swig_getmethods__["time_visible"] = _Leap.Hand_time_visible_get
    if _newclass:
        time_visible = _swig_property(_Leap.Hand_time_visible_get)
    __swig_getmethods__["confidence"] = _Leap.Hand_confidence_get
    if _newclass:
        confidence = _swig_property(_Leap.Hand_confidence_get)
    __swig_getmethods__["is_left"] = _Leap.Hand_is_left_get
    if _newclass:
        is_left = _swig_property(_Leap.Hand_is_left_get)
    __swig_getmethods__["is_right"] = _Leap.Hand_is_right_get
    if _newclass:
        is_right = _swig_property(_Leap.Hand_is_right_get)
    __swig_getmethods__["frame"] = _Leap.Hand_frame_get
    if _newclass:
        frame = _swig_property(_Leap.Hand_frame_get)
    __swig_getmethods__["arm"] = _Leap.Hand_arm_get
    if _newclass:
        arm = _swig_property(_Leap.Hand_arm_get)
    __swig_destroy__ = _Leap.delete_Hand
    __del__ = lambda self: None
Hand_swigregister = _Leap.Hand_swigregister
Hand_swigregister(Hand)
Hand.invalid = _Leap.cvar.Hand_invalid

class Gesture(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Gesture, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Gesture, name)
    __repr__ = _swig_repr
    TYPE_INVALID = _Leap.Gesture_TYPE_INVALID
    TYPE_SWIPE = _Leap.Gesture_TYPE_SWIPE
    TYPE_CIRCLE = _Leap.Gesture_TYPE_CIRCLE
    TYPE_SCREEN_TAP = _Leap.Gesture_TYPE_SCREEN_TAP
    TYPE_KEY_TAP = _Leap.Gesture_TYPE_KEY_TAP
    STATE_INVALID = _Leap.Gesture_STATE_INVALID
    STATE_START = _Leap.Gesture_STATE_START
    STATE_UPDATE = _Leap.Gesture_STATE_UPDATE
    STATE_STOP = _Leap.Gesture_STATE_STOP

    def __init__(self, *args):
        this = _Leap.new_Gesture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, rhs):
        return _Leap.Gesture___eq__(self, rhs)

    def __ne__(self, rhs):
        return _Leap.Gesture___ne__(self, rhs)

    def __str__(self):
        return _Leap.Gesture___str__(self)
    __swig_getmethods__["type"] = _Leap.Gesture_type_get
    if _newclass:
        type = _swig_property(_Leap.Gesture_type_get)
    __swig_getmethods__["state"] = _Leap.Gesture_state_get
    if _newclass:
        state = _swig_property(_Leap.Gesture_state_get)
    __swig_getmethods__["id"] = _Leap.Gesture_id_get
    if _newclass:
        id = _swig_property(_Leap.Gesture_id_get)
    __swig_getmethods__["duration"] = _Leap.Gesture_duration_get
    if _newclass:
        duration = _swig_property(_Leap.Gesture_duration_get)
    __swig_getmethods__["duration_seconds"] = _Leap.Gesture_duration_seconds_get
    if _newclass:
        duration_seconds = _swig_property(_Leap.Gesture_duration_seconds_get)
    __swig_getmethods__["frame"] = _Leap.Gesture_frame_get
    if _newclass:
        frame = _swig_property(_Leap.Gesture_frame_get)
    __swig_getmethods__["hands"] = _Leap.Gesture_hands_get
    if _newclass:
        hands = _swig_property(_Leap.Gesture_hands_get)
    __swig_getmethods__["pointables"] = _Leap.Gesture_pointables_get
    if _newclass:
        pointables = _swig_property(_Leap.Gesture_pointables_get)
    __swig_getmethods__["is_valid"] = _Leap.Gesture_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Gesture_is_valid_get)
    __swig_destroy__ = _Leap.delete_Gesture
    __del__ = lambda self: None
Gesture_swigregister = _Leap.Gesture_swigregister
Gesture_swigregister(Gesture)
Gesture.invalid = _Leap.cvar.Gesture_invalid

class SwipeGesture(Gesture):
    __swig_setmethods__ = {}
    for _s in [Gesture]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwipeGesture, name, value)
    __swig_getmethods__ = {}
    for _s in [Gesture]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SwipeGesture, name)
    __repr__ = _swig_repr
    if _newclass:
        class_type = staticmethod(_Leap.SwipeGesture_class_type)
    else:
        class_type = _Leap.SwipeGesture_class_type

    def __init__(self, *args):
        this = _Leap.new_SwipeGesture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_getmethods__["start_position"] = _Leap.SwipeGesture_start_position_get
    if _newclass:
        start_position = _swig_property(_Leap.SwipeGesture_start_position_get)
    __swig_getmethods__["position"] = _Leap.SwipeGesture_position_get
    if _newclass:
        position = _swig_property(_Leap.SwipeGesture_position_get)
    __swig_getmethods__["direction"] = _Leap.SwipeGesture_direction_get
    if _newclass:
        direction = _swig_property(_Leap.SwipeGesture_direction_get)
    __swig_getmethods__["speed"] = _Leap.SwipeGesture_speed_get
    if _newclass:
        speed = _swig_property(_Leap.SwipeGesture_speed_get)
    __swig_getmethods__["pointable"] = _Leap.SwipeGesture_pointable_get
    if _newclass:
        pointable = _swig_property(_Leap.SwipeGesture_pointable_get)
    __swig_destroy__ = _Leap.delete_SwipeGesture
    __del__ = lambda self: None
SwipeGesture_swigregister = _Leap.SwipeGesture_swigregister
SwipeGesture_swigregister(SwipeGesture)

def SwipeGesture_class_type():
    return _Leap.SwipeGesture_class_type()
SwipeGesture_class_type = _Leap.SwipeGesture_class_type

class CircleGesture(Gesture):
    __swig_setmethods__ = {}
    for _s in [Gesture]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CircleGesture, name, value)
    __swig_getmethods__ = {}
    for _s in [Gesture]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CircleGesture, name)
    __repr__ = _swig_repr
    if _newclass:
        class_type = staticmethod(_Leap.CircleGesture_class_type)
    else:
        class_type = _Leap.CircleGesture_class_type

    def __init__(self, *args):
        this = _Leap.new_CircleGesture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_getmethods__["center"] = _Leap.CircleGesture_center_get
    if _newclass:
        center = _swig_property(_Leap.CircleGesture_center_get)
    __swig_getmethods__["normal"] = _Leap.CircleGesture_normal_get
    if _newclass:
        normal = _swig_property(_Leap.CircleGesture_normal_get)
    __swig_getmethods__["progress"] = _Leap.CircleGesture_progress_get
    if _newclass:
        progress = _swig_property(_Leap.CircleGesture_progress_get)
    __swig_getmethods__["radius"] = _Leap.CircleGesture_radius_get
    if _newclass:
        radius = _swig_property(_Leap.CircleGesture_radius_get)
    __swig_getmethods__["pointable"] = _Leap.CircleGesture_pointable_get
    if _newclass:
        pointable = _swig_property(_Leap.CircleGesture_pointable_get)
    __swig_destroy__ = _Leap.delete_CircleGesture
    __del__ = lambda self: None
CircleGesture_swigregister = _Leap.CircleGesture_swigregister
CircleGesture_swigregister(CircleGesture)

def CircleGesture_class_type():
    return _Leap.CircleGesture_class_type()
CircleGesture_class_type = _Leap.CircleGesture_class_type

class ScreenTapGesture(Gesture):
    __swig_setmethods__ = {}
    for _s in [Gesture]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScreenTapGesture, name, value)
    __swig_getmethods__ = {}
    for _s in [Gesture]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScreenTapGesture, name)
    __repr__ = _swig_repr
    if _newclass:
        class_type = staticmethod(_Leap.ScreenTapGesture_class_type)
    else:
        class_type = _Leap.ScreenTapGesture_class_type

    def __init__(self, *args):
        this = _Leap.new_ScreenTapGesture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_getmethods__["position"] = _Leap.ScreenTapGesture_position_get
    if _newclass:
        position = _swig_property(_Leap.ScreenTapGesture_position_get)
    __swig_getmethods__["direction"] = _Leap.ScreenTapGesture_direction_get
    if _newclass:
        direction = _swig_property(_Leap.ScreenTapGesture_direction_get)
    __swig_getmethods__["progress"] = _Leap.ScreenTapGesture_progress_get
    if _newclass:
        progress = _swig_property(_Leap.ScreenTapGesture_progress_get)
    __swig_getmethods__["pointable"] = _Leap.ScreenTapGesture_pointable_get
    if _newclass:
        pointable = _swig_property(_Leap.ScreenTapGesture_pointable_get)
    __swig_destroy__ = _Leap.delete_ScreenTapGesture
    __del__ = lambda self: None
ScreenTapGesture_swigregister = _Leap.ScreenTapGesture_swigregister
ScreenTapGesture_swigregister(ScreenTapGesture)

def ScreenTapGesture_class_type():
    return _Leap.ScreenTapGesture_class_type()
ScreenTapGesture_class_type = _Leap.ScreenTapGesture_class_type

class KeyTapGesture(Gesture):
    __swig_setmethods__ = {}
    for _s in [Gesture]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyTapGesture, name, value)
    __swig_getmethods__ = {}
    for _s in [Gesture]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KeyTapGesture, name)
    __repr__ = _swig_repr
    if _newclass:
        class_type = staticmethod(_Leap.KeyTapGesture_class_type)
    else:
        class_type = _Leap.KeyTapGesture_class_type

    def __init__(self, *args):
        this = _Leap.new_KeyTapGesture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_getmethods__["position"] = _Leap.KeyTapGesture_position_get
    if _newclass:
        position = _swig_property(_Leap.KeyTapGesture_position_get)
    __swig_getmethods__["direction"] = _Leap.KeyTapGesture_direction_get
    if _newclass:
        direction = _swig_property(_Leap.KeyTapGesture_direction_get)
    __swig_getmethods__["progress"] = _Leap.KeyTapGesture_progress_get
    if _newclass:
        progress = _swig_property(_Leap.KeyTapGesture_progress_get)
    __swig_getmethods__["pointable"] = _Leap.KeyTapGesture_pointable_get
    if _newclass:
        pointable = _swig_property(_Leap.KeyTapGesture_pointable_get)
    __swig_destroy__ = _Leap.delete_KeyTapGesture
    __del__ = lambda self: None
KeyTapGesture_swigregister = _Leap.KeyTapGesture_swigregister
KeyTapGesture_swigregister(KeyTapGesture)

def KeyTapGesture_class_type():
    return _Leap.KeyTapGesture_class_type()
KeyTapGesture_class_type = _Leap.KeyTapGesture_class_type

class Device(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Device, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Device, name)
    __repr__ = _swig_repr
    TYPE_PERIPHERAL = _Leap.Device_TYPE_PERIPHERAL
    TYPE_HP_LEGACY = _Leap.Device_TYPE_HP_LEGACY
    TYPE_KEYBOARD = _Leap.Device_TYPE_KEYBOARD
    TYPE_LAPTOP = _Leap.Device_TYPE_LAPTOP

    def __init__(self):
        this = _Leap.new_Device()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def distance_to_boundary(self, position):
        return _Leap.Device_distance_to_boundary(self, position)

    def __eq__(self, arg2):
        return _Leap.Device___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Device___ne__(self, arg2)

    def __str__(self):
        return _Leap.Device___str__(self)
    __swig_getmethods__["horizontal_view_angle"] = _Leap.Device_horizontal_view_angle_get
    if _newclass:
        horizontal_view_angle = _swig_property(_Leap.Device_horizontal_view_angle_get)
    __swig_getmethods__["vertical_view_angle"] = _Leap.Device_vertical_view_angle_get
    if _newclass:
        vertical_view_angle = _swig_property(_Leap.Device_vertical_view_angle_get)
    __swig_getmethods__["range"] = _Leap.Device_range_get
    if _newclass:
        range = _swig_property(_Leap.Device_range_get)
    __swig_getmethods__["baseline"] = _Leap.Device_baseline_get
    if _newclass:
        baseline = _swig_property(_Leap.Device_baseline_get)
    __swig_getmethods__["is_valid"] = _Leap.Device_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Device_is_valid_get)
    __swig_getmethods__["is_embedded"] = _Leap.Device_is_embedded_get
    if _newclass:
        is_embedded = _swig_property(_Leap.Device_is_embedded_get)
    __swig_getmethods__["is_streaming"] = _Leap.Device_is_streaming_get
    if _newclass:
        is_streaming = _swig_property(_Leap.Device_is_streaming_get)
    __swig_getmethods__["is_smudged"] = _Leap.Device_is_smudged_get
    if _newclass:
        is_smudged = _swig_property(_Leap.Device_is_smudged_get)
    __swig_getmethods__["is_lighting_bad"] = _Leap.Device_is_lighting_bad_get
    if _newclass:
        is_lighting_bad = _swig_property(_Leap.Device_is_lighting_bad_get)
    __swig_getmethods__["type"] = _Leap.Device_type_get
    if _newclass:
        type = _swig_property(_Leap.Device_type_get)
    __swig_getmethods__["serial_number"] = _Leap.Device_serial_number_get
    if _newclass:
        serial_number = _swig_property(_Leap.Device_serial_number_get)
    __swig_getmethods__["position"] = _Leap.Device_position_get
    if _newclass:
        position = _swig_property(_Leap.Device_position_get)
    __swig_getmethods__["orientation"] = _Leap.Device_orientation_get
    if _newclass:
        orientation = _swig_property(_Leap.Device_orientation_get)
    __swig_destroy__ = _Leap.delete_Device
    __del__ = lambda self: None
Device_swigregister = _Leap.Device_swigregister
Device_swigregister(Device)
Device.invalid = _Leap.cvar.Device_invalid

class FailedDevice(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FailedDevice, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FailedDevice, name)
    __repr__ = _swig_repr
    FAIL_UNKNOWN = _Leap.FailedDevice_FAIL_UNKNOWN
    FAIL_CALIBRATION = _Leap.FailedDevice_FAIL_CALIBRATION
    FAIL_FIRMWARE = _Leap.FailedDevice_FAIL_FIRMWARE
    FAIL_TRANSPORT = _Leap.FailedDevice_FAIL_TRANSPORT
    FAIL_CONTROL = _Leap.FailedDevice_FAIL_CONTROL
    FAIL_COUNT = _Leap.FailedDevice_FAIL_COUNT

    def __init__(self):
        this = _Leap.new_FailedDevice()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def is_valid(self):
        return _Leap.FailedDevice_is_valid(self)
    if _newclass:
        invalid = staticmethod(_Leap.FailedDevice_invalid)
    else:
        invalid = _Leap.FailedDevice_invalid

    def __eq__(self, arg2):
        return _Leap.FailedDevice___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.FailedDevice___ne__(self, arg2)
    __swig_getmethods__["pnp_id"] = _Leap.FailedDevice_pnp_id_get
    if _newclass:
        pnp_id = _swig_property(_Leap.FailedDevice_pnp_id_get)
    __swig_getmethods__["failure"] = _Leap.FailedDevice_failure_get
    if _newclass:
        failure = _swig_property(_Leap.FailedDevice_failure_get)
    __swig_destroy__ = _Leap.delete_FailedDevice
    __del__ = lambda self: None
FailedDevice_swigregister = _Leap.FailedDevice_swigregister
FailedDevice_swigregister(FailedDevice)

def FailedDevice_invalid():
    return _Leap.FailedDevice_invalid()
FailedDevice_invalid = _Leap.FailedDevice_invalid

class Image(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Image, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Image, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_Image()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def data(self, dst):
        return _Leap.Image_data(self, dst)

    def distortion(self, dst):
        return _Leap.Image_distortion(self, dst)
    INFRARED = _Leap.Image_INFRARED
    IBRG = _Leap.Image_IBRG

    def rectify(self, uv):
        return _Leap.Image_rectify(self, uv)

    def warp(self, xy):
        return _Leap.Image_warp(self, xy)

    def __eq__(self, arg2):
        return _Leap.Image___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Image___ne__(self, arg2)

    def __str__(self):
        return _Leap.Image___str__(self)
    __swig_getmethods__["sequence_id"] = _Leap.Image_sequence_id_get
    if _newclass:
        sequence_id = _swig_property(_Leap.Image_sequence_id_get)
    __swig_getmethods__["id"] = _Leap.Image_id_get
    if _newclass:
        id = _swig_property(_Leap.Image_id_get)
    __swig_getmethods__["width"] = _Leap.Image_width_get
    if _newclass:
        width = _swig_property(_Leap.Image_width_get)
    __swig_getmethods__["height"] = _Leap.Image_height_get
    if _newclass:
        height = _swig_property(_Leap.Image_height_get)
    __swig_getmethods__["bytes_per_pixel"] = _Leap.Image_bytes_per_pixel_get
    if _newclass:
        bytes_per_pixel = _swig_property(_Leap.Image_bytes_per_pixel_get)
    __swig_getmethods__["format"] = _Leap.Image_format_get
    if _newclass:
        format = _swig_property(_Leap.Image_format_get)
    __swig_getmethods__["distortion_width"] = _Leap.Image_distortion_width_get
    if _newclass:
        distortion_width = _swig_property(_Leap.Image_distortion_width_get)
    __swig_getmethods__["distortion_height"] = _Leap.Image_distortion_height_get
    if _newclass:
        distortion_height = _swig_property(_Leap.Image_distortion_height_get)
    __swig_getmethods__["ray_offset_x"] = _Leap.Image_ray_offset_x_get
    if _newclass:
        ray_offset_x = _swig_property(_Leap.Image_ray_offset_x_get)
    __swig_getmethods__["ray_offset_y"] = _Leap.Image_ray_offset_y_get
    if _newclass:
        ray_offset_y = _swig_property(_Leap.Image_ray_offset_y_get)
    __swig_getmethods__["ray_scale_x"] = _Leap.Image_ray_scale_x_get
    if _newclass:
        ray_scale_x = _swig_property(_Leap.Image_ray_scale_x_get)
    __swig_getmethods__["ray_scale_y"] = _Leap.Image_ray_scale_y_get
    if _newclass:
        ray_scale_y = _swig_property(_Leap.Image_ray_scale_y_get)
    __swig_getmethods__["timestamp"] = _Leap.Image_timestamp_get
    if _newclass:
        timestamp = _swig_property(_Leap.Image_timestamp_get)
    __swig_getmethods__["is_valid"] = _Leap.Image_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Image_is_valid_get)

    def data(self):
        ptr = byte_array(self.width * self.height * self.bytes_per_pixel)
        LeapPython.Image_data(self, ptr)
        return ptr
    def distortion(self):
        ptr = float_array(self.distortion_width * self.distortion_height)
        LeapPython.Image_distortion(self, ptr)
        return ptr
    __swig_getmethods__["data"] = data
    if _newclass:data = _swig_property(data)
    __swig_getmethods__["distortion"] = distortion
    if _newclass:distortion = _swig_property(distortion)

    __swig_getmethods__["data_pointer"] = _Leap.Image_data_pointer_get
    if _newclass:
        data_pointer = _swig_property(_Leap.Image_data_pointer_get)
    __swig_getmethods__["distortion_pointer"] = _Leap.Image_distortion_pointer_get
    if _newclass:
        distortion_pointer = _swig_property(_Leap.Image_distortion_pointer_get)
    __swig_destroy__ = _Leap.delete_Image
    __del__ = lambda self: None
Image_swigregister = _Leap.Image_swigregister
Image_swigregister(Image)
Image.invalid = _Leap.cvar.Image_invalid

class PointableList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointableList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PointableList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_PointableList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.PointableList___len__(self)

    def __getitem__(self, index):
        return _Leap.PointableList___getitem__(self, index)

    def append(self, *args):
        return _Leap.PointableList_append(self, *args)

    def extended(self):
        return _Leap.PointableList_extended(self)
    __swig_getmethods__["is_empty"] = _Leap.PointableList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.PointableList_is_empty_get)
    __swig_getmethods__["leftmost"] = _Leap.PointableList_leftmost_get
    if _newclass:
        leftmost = _swig_property(_Leap.PointableList_leftmost_get)
    __swig_getmethods__["rightmost"] = _Leap.PointableList_rightmost_get
    if _newclass:
        rightmost = _swig_property(_Leap.PointableList_rightmost_get)
    __swig_getmethods__["frontmost"] = _Leap.PointableList_frontmost_get
    if _newclass:
        frontmost = _swig_property(_Leap.PointableList_frontmost_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_PointableList
    __del__ = lambda self: None
PointableList_swigregister = _Leap.PointableList_swigregister
PointableList_swigregister(PointableList)

class FingerList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FingerList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FingerList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_FingerList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.FingerList___len__(self)

    def __getitem__(self, index):
        return _Leap.FingerList___getitem__(self, index)

    def append(self, other):
        return _Leap.FingerList_append(self, other)

    def extended(self):
        return _Leap.FingerList_extended(self)

    def finger_type(self, type):
        return _Leap.FingerList_finger_type(self, type)
    __swig_getmethods__["is_empty"] = _Leap.FingerList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.FingerList_is_empty_get)
    __swig_getmethods__["leftmost"] = _Leap.FingerList_leftmost_get
    if _newclass:
        leftmost = _swig_property(_Leap.FingerList_leftmost_get)
    __swig_getmethods__["rightmost"] = _Leap.FingerList_rightmost_get
    if _newclass:
        rightmost = _swig_property(_Leap.FingerList_rightmost_get)
    __swig_getmethods__["frontmost"] = _Leap.FingerList_frontmost_get
    if _newclass:
        frontmost = _swig_property(_Leap.FingerList_frontmost_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_FingerList
    __del__ = lambda self: None
FingerList_swigregister = _Leap.FingerList_swigregister
FingerList_swigregister(FingerList)

class ToolList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_ToolList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.ToolList___len__(self)

    def __getitem__(self, index):
        return _Leap.ToolList___getitem__(self, index)

    def append(self, other):
        return _Leap.ToolList_append(self, other)
    __swig_getmethods__["is_empty"] = _Leap.ToolList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.ToolList_is_empty_get)
    __swig_getmethods__["leftmost"] = _Leap.ToolList_leftmost_get
    if _newclass:
        leftmost = _swig_property(_Leap.ToolList_leftmost_get)
    __swig_getmethods__["rightmost"] = _Leap.ToolList_rightmost_get
    if _newclass:
        rightmost = _swig_property(_Leap.ToolList_rightmost_get)
    __swig_getmethods__["frontmost"] = _Leap.ToolList_frontmost_get
    if _newclass:
        frontmost = _swig_property(_Leap.ToolList_frontmost_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_ToolList
    __del__ = lambda self: None
ToolList_swigregister = _Leap.ToolList_swigregister
ToolList_swigregister(ToolList)

class HandList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HandList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HandList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_HandList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.HandList___len__(self)

    def __getitem__(self, index):
        return _Leap.HandList___getitem__(self, index)

    def append(self, other):
        return _Leap.HandList_append(self, other)
    __swig_getmethods__["is_empty"] = _Leap.HandList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.HandList_is_empty_get)
    __swig_getmethods__["leftmost"] = _Leap.HandList_leftmost_get
    if _newclass:
        leftmost = _swig_property(_Leap.HandList_leftmost_get)
    __swig_getmethods__["rightmost"] = _Leap.HandList_rightmost_get
    if _newclass:
        rightmost = _swig_property(_Leap.HandList_rightmost_get)
    __swig_getmethods__["frontmost"] = _Leap.HandList_frontmost_get
    if _newclass:
        frontmost = _swig_property(_Leap.HandList_frontmost_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_HandList
    __del__ = lambda self: None
HandList_swigregister = _Leap.HandList_swigregister
HandList_swigregister(HandList)

class GestureList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GestureList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GestureList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_GestureList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.GestureList___len__(self)

    def __getitem__(self, index):
        return _Leap.GestureList___getitem__(self, index)

    def append(self, other):
        return _Leap.GestureList_append(self, other)
    __swig_getmethods__["is_empty"] = _Leap.GestureList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.GestureList_is_empty_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_GestureList
    __del__ = lambda self: None
GestureList_swigregister = _Leap.GestureList_swigregister
GestureList_swigregister(GestureList)

class DeviceList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_DeviceList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.DeviceList___len__(self)

    def __getitem__(self, index):
        return _Leap.DeviceList___getitem__(self, index)

    def append(self, other):
        return _Leap.DeviceList_append(self, other)
    __swig_getmethods__["is_empty"] = _Leap.DeviceList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.DeviceList_is_empty_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_DeviceList
    __del__ = lambda self: None
DeviceList_swigregister = _Leap.DeviceList_swigregister
DeviceList_swigregister(DeviceList)

class FailedDeviceList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FailedDeviceList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FailedDeviceList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_FailedDeviceList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.FailedDeviceList___len__(self)

    def __getitem__(self, index):
        return _Leap.FailedDeviceList___getitem__(self, index)

    def append(self, other):
        return _Leap.FailedDeviceList_append(self, other)
    __swig_getmethods__["is_empty"] = _Leap.FailedDeviceList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.FailedDeviceList_is_empty_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_FailedDeviceList
    __del__ = lambda self: None
FailedDeviceList_swigregister = _Leap.FailedDeviceList_swigregister
FailedDeviceList_swigregister(FailedDeviceList)

class ImageList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_ImageList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __len__(self):
        return _Leap.ImageList___len__(self)

    def __getitem__(self, index):
        return _Leap.ImageList___getitem__(self, index)

    def append(self, other):
        return _Leap.ImageList_append(self, other)
    __swig_getmethods__["is_empty"] = _Leap.ImageList_is_empty_get
    if _newclass:
        is_empty = _swig_property(_Leap.ImageList_is_empty_get)

    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _Leap.delete_ImageList
    __del__ = lambda self: None
ImageList_swigregister = _Leap.ImageList_swigregister
ImageList_swigregister(ImageList)

class InteractionBox(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteractionBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InteractionBox, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_InteractionBox()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def normalize_point(self, position, clamp=True):
        return _Leap.InteractionBox_normalize_point(self, position, clamp)

    def denormalize_point(self, normalizedPosition):
        return _Leap.InteractionBox_denormalize_point(self, normalizedPosition)

    def __eq__(self, arg2):
        return _Leap.InteractionBox___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.InteractionBox___ne__(self, arg2)

    def __str__(self):
        return _Leap.InteractionBox___str__(self)
    __swig_getmethods__["center"] = _Leap.InteractionBox_center_get
    if _newclass:
        center = _swig_property(_Leap.InteractionBox_center_get)
    __swig_getmethods__["width"] = _Leap.InteractionBox_width_get
    if _newclass:
        width = _swig_property(_Leap.InteractionBox_width_get)
    __swig_getmethods__["height"] = _Leap.InteractionBox_height_get
    if _newclass:
        height = _swig_property(_Leap.InteractionBox_height_get)
    __swig_getmethods__["depth"] = _Leap.InteractionBox_depth_get
    if _newclass:
        depth = _swig_property(_Leap.InteractionBox_depth_get)
    __swig_getmethods__["is_valid"] = _Leap.InteractionBox_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.InteractionBox_is_valid_get)
    __swig_destroy__ = _Leap.delete_InteractionBox
    __del__ = lambda self: None
InteractionBox_swigregister = _Leap.InteractionBox_swigregister
InteractionBox_swigregister(InteractionBox)
InteractionBox.invalid = _Leap.cvar.InteractionBox_invalid

class Frame(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Frame, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Frame, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_Frame()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hand(self, id):
        return _Leap.Frame_hand(self, id)

    def pointable(self, id):
        return _Leap.Frame_pointable(self, id)

    def finger(self, id):
        return _Leap.Frame_finger(self, id)

    def tool(self, id):
        return _Leap.Frame_tool(self, id)

    def gesture(self, id):
        return _Leap.Frame_gesture(self, id)

    def gestures(self, *args):
        return _Leap.Frame_gestures(self, *args)

    def translation(self, sinceFrame):
        return _Leap.Frame_translation(self, sinceFrame)

    def translation_probability(self, sinceFrame):
        return _Leap.Frame_translation_probability(self, sinceFrame)

    def rotation_axis(self, sinceFrame):
        return _Leap.Frame_rotation_axis(self, sinceFrame)

    def rotation_angle(self, *args):
        return _Leap.Frame_rotation_angle(self, *args)

    def rotation_matrix(self, sinceFrame):
        return _Leap.Frame_rotation_matrix(self, sinceFrame)

    def rotation_probability(self, sinceFrame):
        return _Leap.Frame_rotation_probability(self, sinceFrame)

    def scale_factor(self, sinceFrame):
        return _Leap.Frame_scale_factor(self, sinceFrame)

    def scale_probability(self, sinceFrame):
        return _Leap.Frame_scale_probability(self, sinceFrame)

    def __eq__(self, arg2):
        return _Leap.Frame___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Leap.Frame___ne__(self, arg2)

    def serialize(self, ptr):
        return _Leap.Frame_serialize(self, ptr)

    def deserialize(self, ptr, length):
        return _Leap.Frame_deserialize(self, ptr, length)

    def __str__(self):
        return _Leap.Frame___str__(self)
    __swig_getmethods__["id"] = _Leap.Frame_id_get
    if _newclass:
        id = _swig_property(_Leap.Frame_id_get)
    __swig_getmethods__["timestamp"] = _Leap.Frame_timestamp_get
    if _newclass:
        timestamp = _swig_property(_Leap.Frame_timestamp_get)
    __swig_getmethods__["current_frames_per_second"] = _Leap.Frame_current_frames_per_second_get
    if _newclass:
        current_frames_per_second = _swig_property(_Leap.Frame_current_frames_per_second_get)
    __swig_getmethods__["pointables"] = _Leap.Frame_pointables_get
    if _newclass:
        pointables = _swig_property(_Leap.Frame_pointables_get)
    __swig_getmethods__["fingers"] = _Leap.Frame_fingers_get
    if _newclass:
        fingers = _swig_property(_Leap.Frame_fingers_get)
    __swig_getmethods__["tools"] = _Leap.Frame_tools_get
    if _newclass:
        tools = _swig_property(_Leap.Frame_tools_get)
    __swig_getmethods__["hands"] = _Leap.Frame_hands_get
    if _newclass:
        hands = _swig_property(_Leap.Frame_hands_get)
    __swig_getmethods__["images"] = _Leap.Frame_images_get
    if _newclass:
        images = _swig_property(_Leap.Frame_images_get)
    __swig_getmethods__["raw_images"] = _Leap.Frame_raw_images_get
    if _newclass:
        raw_images = _swig_property(_Leap.Frame_raw_images_get)
    __swig_getmethods__["is_valid"] = _Leap.Frame_is_valid_get
    if _newclass:
        is_valid = _swig_property(_Leap.Frame_is_valid_get)
    __swig_getmethods__["interaction_box"] = _Leap.Frame_interaction_box_get
    if _newclass:
        interaction_box = _swig_property(_Leap.Frame_interaction_box_get)
    __swig_getmethods__["serialize_length"] = _Leap.Frame_serialize_length_get
    if _newclass:
        serialize_length = _swig_property(_Leap.Frame_serialize_length_get)

    def serialize(self):
        length = self.serialize_length
        str = byte_array(length)
        LeapPython.Frame_serialize(self, str)
        return (str, length)
    def deserialize(self, tup):
        LeapPython.Frame_deserialize(self, tup[0], tup[1])
    __swig_getmethods__["serialize"] = serialize
    if _newclass:serialize = _swig_property(serialize)

    __swig_destroy__ = _Leap.delete_Frame
    __del__ = lambda self: None
Frame_swigregister = _Leap.Frame_swigregister
Frame_swigregister(Frame)
Frame.invalid = _Leap.cvar.Frame_invalid

class BugReport(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BugReport, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BugReport, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_BugReport()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def begin_recording(self):
        return _Leap.BugReport_begin_recording(self)

    def end_recording(self):
        return _Leap.BugReport_end_recording(self)
    __swig_getmethods__["is_active"] = _Leap.BugReport_is_active_get
    if _newclass:
        is_active = _swig_property(_Leap.BugReport_is_active_get)
    __swig_getmethods__["progress"] = _Leap.BugReport_progress_get
    if _newclass:
        progress = _swig_property(_Leap.BugReport_progress_get)
    __swig_getmethods__["duration"] = _Leap.BugReport_duration_get
    if _newclass:
        duration = _swig_property(_Leap.BugReport_duration_get)
    __swig_destroy__ = _Leap.delete_BugReport
    __del__ = lambda self: None
BugReport_swigregister = _Leap.BugReport_swigregister
BugReport_swigregister(BugReport)

class Config(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Config, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Config, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Leap.new_Config()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    TYPE_UNKNOWN = _Leap.Config_TYPE_UNKNOWN
    TYPE_BOOLEAN = _Leap.Config_TYPE_BOOLEAN
    TYPE_INT32 = _Leap.Config_TYPE_INT32
    TYPE_FLOAT = _Leap.Config_TYPE_FLOAT
    TYPE_STRING = _Leap.Config_TYPE_STRING



















    def save(self):
        return _Leap.Config_save(self)

    def get(self, *args):
      type = LeapPython.Config_type(self, *args)
      if type == LeapPython.Config_TYPE_BOOLEAN:
        return LeapPython.Config_get_bool(self, *args)
      elif type == LeapPython.Config_TYPE_INT32:
        return LeapPython.Config_get_int_32(self, *args)
      elif type == LeapPython.Config_TYPE_FLOAT:
        return LeapPython.Config_get_float(self, *args)
      elif type == LeapPython.Config_TYPE_STRING:
        return LeapPython.Config_get_string(self, *args)
      return None
    def set(self, *args):
      type = LeapPython.Config_type(self, *args[:-1])  # Do not pass value through
      if type == LeapPython.Config_TYPE_BOOLEAN:
        return LeapPython.Config_set_bool(self, *args)
      elif type == LeapPython.Config_TYPE_INT32:
        return LeapPython.Config_set_int_32(self, *args)
      elif type == LeapPython.Config_TYPE_FLOAT:
        return LeapPython.Config_set_float(self, *args)
      elif type == LeapPython.Config_TYPE_STRING:
        return LeapPython.Config_set_string(self, *args)
      return False

    __swig_destroy__ = _Leap.delete_Config
    __del__ = lambda self: None
Config_swigregister = _Leap.Config_swigregister
Config_swigregister(Config)

class Controller(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Controller, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Controller, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _Leap.delete_Controller
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _Leap.new_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def is_service_connected(self):
        return _Leap.Controller_is_service_connected(self)
    POLICY_DEFAULT = _Leap.Controller_POLICY_DEFAULT
    POLICY_BACKGROUND_FRAMES = _Leap.Controller_POLICY_BACKGROUND_FRAMES
    POLICY_IMAGES = _Leap.Controller_POLICY_IMAGES
    POLICY_OPTIMIZE_HMD = _Leap.Controller_POLICY_OPTIMIZE_HMD
    POLICY_ALLOW_PAUSE_RESUME = _Leap.Controller_POLICY_ALLOW_PAUSE_RESUME
    POLICY_RAW_IMAGES = _Leap.Controller_POLICY_RAW_IMAGES

    def set_policy_flags(self, flags):
        return _Leap.Controller_set_policy_flags(self, flags)

    def set_policy(self, policy):
        return _Leap.Controller_set_policy(self, policy)

    def clear_policy(self, policy):
        return _Leap.Controller_clear_policy(self, policy)

    def is_policy_set(self, policy):
        return _Leap.Controller_is_policy_set(self, policy)

    def add_listener(self, listener):
        return _Leap.Controller_add_listener(self, listener)

    def remove_listener(self, listener):
        return _Leap.Controller_remove_listener(self, listener)

    def frame(self, history=0):
        return _Leap.Controller_frame(self, history)

    def failed_devices(self):
        return _Leap.Controller_failed_devices(self)

    def enable_gesture(self, type, enable=True):
        return _Leap.Controller_enable_gesture(self, type, enable)

    def is_gesture_enabled(self, type):
        return _Leap.Controller_is_gesture_enabled(self, type)

    def set_paused(self, pause):
        return _Leap.Controller_set_paused(self, pause)

    def is_paused(self):
        return _Leap.Controller_is_paused(self)

    def now(self):
        return _Leap.Controller_now(self)
    __swig_getmethods__["is_connected"] = _Leap.Controller_is_connected_get
    if _newclass:
        is_connected = _swig_property(_Leap.Controller_is_connected_get)
    __swig_getmethods__["has_focus"] = _Leap.Controller_has_focus_get
    if _newclass:
        has_focus = _swig_property(_Leap.Controller_has_focus_get)
    __swig_getmethods__["policy_flags"] = _Leap.Controller_policy_flags_get
    if _newclass:
        policy_flags = _swig_property(_Leap.Controller_policy_flags_get)
    __swig_getmethods__["config"] = _Leap.Controller_config_get
    if _newclass:
        config = _swig_property(_Leap.Controller_config_get)
    __swig_getmethods__["images"] = _Leap.Controller_images_get
    if _newclass:
        images = _swig_property(_Leap.Controller_images_get)
    __swig_getmethods__["raw_images"] = _Leap.Controller_raw_images_get
    if _newclass:
        raw_images = _swig_property(_Leap.Controller_raw_images_get)
    __swig_getmethods__["devices"] = _Leap.Controller_devices_get
    if _newclass:
        devices = _swig_property(_Leap.Controller_devices_get)
    __swig_getmethods__["bug_report"] = _Leap.Controller_bug_report_get
    if _newclass:
        bug_report = _swig_property(_Leap.Controller_bug_report_get)
Controller_swigregister = _Leap.Controller_swigregister
Controller_swigregister(Controller)

MESSAGE_UNKNOWN = _Leap.MESSAGE_UNKNOWN
MESSAGE_CRITICAL = _Leap.MESSAGE_CRITICAL
MESSAGE_WARNING = _Leap.MESSAGE_WARNING
MESSAGE_INFORMATION = _Leap.MESSAGE_INFORMATION
class Listener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listener, name)
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == Listener:
            _self = None
        else:
            _self = self
        this = _Leap.new_Listener(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Leap.delete_Listener
    __del__ = lambda self: None

    def on_init(self, arg0):
        return _Leap.Listener_on_init(self, arg0)

    def on_connect(self, arg0):
        return _Leap.Listener_on_connect(self, arg0)

    def on_disconnect(self, arg0):
        return _Leap.Listener_on_disconnect(self, arg0)

    def on_exit(self, arg0):
        return _Leap.Listener_on_exit(self, arg0)

    def on_frame(self, arg0):
        return _Leap.Listener_on_frame(self, arg0)

    def on_focus_gained(self, arg0):
        return _Leap.Listener_on_focus_gained(self, arg0)

    def on_focus_lost(self, arg0):
        return _Leap.Listener_on_focus_lost(self, arg0)

    def on_service_connect(self, arg0):
        return _Leap.Listener_on_service_connect(self, arg0)

    def on_service_disconnect(self, arg0):
        return _Leap.Listener_on_service_disconnect(self, arg0)

    def on_device_change(self, arg0):
        return _Leap.Listener_on_device_change(self, arg0)

    def on_images(self, arg0):
        return _Leap.Listener_on_images(self, arg0)

    def on_service_change(self, arg0):
        return _Leap.Listener_on_service_change(self, arg0)

    def on_device_failure(self, arg0):
        return _Leap.Listener_on_device_failure(self, arg0)

    def on_log_message(self, arg0, severity, timestamp, msg):
        return _Leap.Listener_on_log_message(self, arg0, severity, timestamp, msg)
    def __disown__(self):
        self.this.disown()
        _Leap.disown_Listener(self)
        return weakref_proxy(self)
Listener_swigregister = _Leap.Listener_swigregister
Listener_swigregister(Listener)

# This file is compatible with both classic and new-style classes.


